Sabendo que o brasileiro não tem o hábito de compartilhar o conhecimento em programação, apesar de serem pessoas maravilhosas e com corações enormes, resolvi fazer minha parte.

Neste post vou ensinar passo a passo como configurar um ambiente de desenvolvimento react, utilizando babel e webpack.

Primeiro passo sempre é criar a pasta do projeto. 

Segundo passo é abrir o terminal, dentro da pasta do projeto, para iniciar a instalão dos pacotes que são utilizados na configuração do ambiente de desenvolvimento.

Com o terminal aberto rode os seguintes comandos:

```sh
yarn init -y

yarn add @babel/core @babel/preset-env @babel/preset-react babel-loader webpack webpack-cli webpack-dev-server -D

yarn add react react-dom
```

Caso esteja utilizando npm os comandos devem ser assim:

```sh
npm init -y

npm install @babel/core @babel/preset-env @babel/preset-react babel-loader webpack webpack-cli webpack-dev-server -D 

npm install react react-dom
```

Com tudo instalado vamos partir para a configuração dos pacotes.

Crie um arquivo, na raiz do projeto, chamado babel.config.js.

Adicione o código abaixo em seu arquivo:

```js
module.exports = {
    presets: [
        "@babel/preset-env",
        "@babel/preset-react",
    ]
}
```

Lembrando que o **@babel/preset-env** será responsável por fazer com que o browser entenda os código modernos da ES6, como: arrow functions, imports e exports, o conceito de classes e outras funcionalidades que os navegadores ainda não entendem.

Já o **@babel/preset-react** fará o mesmo trabalho, porém fazendo com que o navegador entenda os código do react como arquivos do tipo **jsx**, onde mistruramos javascript com HTML.

Agora, na raiz do projeto, crie um arquivo chamado **webpack.config.js** e adicione o seguinte código:

```js
const path = require("path");

module.exports = {
    entry: path.resolve(__dirname, 'src', 'index.js'),
    output: {
        path: path.resolve(__dirname, 'public'),
        filename: 'bundle.js',
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader'
                }
            }
        ]
    }
}
```

É necessário importar o pacote **path**, do node, para que não exista conflito entre diferentes sistemas operacionais, pois cada SO utiliza seu próprio separador de diretório, como barra normal ou barra invertida, por exemplo.

Depois é necessário exportar um objeto de configurações.

    1. **entry** indica onde estará seu arquivo de entrar da aplicação.
    2. **output** indica onde o webpack vai gerar o arquivo empacotado e qual o nome ele receberá.
    3. **module** define as regras que o webpack deverá levar em consideração e qual loader deverá utilizar para cada caso.

### Explicando melhor a propriedade **module**

A propriedade **module** tem uma subpropriedade chamada **rulesé**. Rules deve ser um array pois vai receber diversas regras para analisar.

Acima possui apenas a regra de analise de arquivos javascript, ou seja, a propriedade **test** recebe uma expressão regular que vai procurar todos os arquivos que terminem com a extensão **.js**, ou seja, todos os arquivos javascript da aplicação passarão por esta regra.

A propriedade **exclude** elimina a pasta **node_modules** da regra, uma vez que cada desenvolver dor pacotes já deveriam ter feito este procedimento, não cabendo a nós esta responsabilidade.

Depois vem a propriedade **use** que informa ao webpack qual loader ele vai utilizar para as regras configuradas, e neste caso será o pacote **babel-loader**.

Existe loaders específicos para html, imagens, mas será mostrado em outros posts futuros.

### Como iniciar a aplicação para testar a configuração

Crie uma pasta na raiz do seu projeto. Esta pasta deverá conter todos os seus arquivos javascript. 

No caso deste post a pasta foi nomeada **src**.

Dentro da pasta src foi criado um arquivo chamado **index.js**. Dentro deste arquivo adicione o seguinte código:

```js
const soma = (a, b) => a + b;

alert(soma(1,3));
```

Percebam que, apesar de ser uma arrow function bem simples, os navegadores ainda não são capazes de interpretá-la. A maneira correta que os navegadores entenderiam se encontra abaixo:

```js
var soma = function(a, b) {
    return a + b;
}
```

Este código acima será o resultado final, após o nosso código passar pelo loader do babel, onde será alocado no arquivo **bundle.js**, gerado pelo **webpack**.

Começa a fazer sentido agora?

### Isso é besteira!!! Pra que vou programar de uma maneira para gerar um código diferente sendo que posso já programar de uma maneira que o navegador entenda?

Nós programadores temos que sempre querer digitar códigos com mais qualidade, economizando linhas de código e também utilizando as features mais modernas de cada linguagem. Por este motivo devemos sim programar da madeira mais moderna possível, mesmo que os navegadores ainda não entendam, assim estaremos a frente dos demais programadores que ainda utilizam a maneira antiga.

### Continuando...

Depois de criar o arquivo index, dendo da pasta src, vá a té seu arquivo **package.json** e crie um comando dentra da propriedade **scripts** para que possamos executar sempre que quisermos gerar o bundle da aplicação.

```json
"scripts": {
    "build": "webpack --mode development"
},
```

Agora sempre que rodarmos o comando abaixo, teremos o nosso webpack gerando o empacotamento de todo nosso código javascript.

```sh
yarn build

// ou

npm run build
```

### Fazendo teste no HTML

Para finalizar nosso post e certificar que o bundle está sendo gerado corretamente, crie um arquivo chamado **index.html**, dentro da pasta public e adicione o seguinte código:


```html

```

